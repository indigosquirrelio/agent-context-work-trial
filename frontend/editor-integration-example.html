<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Integration Example - Unsaved Edit Tracking</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .editor-container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .editor-header {
            background-color: #2196f3;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .editor-header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #4caf50;
        }
        
        .status-dot.unsaved {
            background-color: #ff9800;
        }
        
        .status-dot.conflict {
            background-color: #f44336;
        }
        
        .editor-content {
            padding: 20px;
        }
        
        .file-info {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #2196f3;
        }
        
        .editor-textarea {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        }
        
        .editor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }
        
        .btn-primary {
            background-color: #2196f3;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #1976d2;
        }
        
        .btn-success {
            background-color: #4caf50;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #388e3c;
        }
        
        .btn-warning {
            background-color: #ff9800;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #f57c00;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .btn-info {
            background-color: #17a2b8;
            color: white;
        }
        
        .btn-info:hover {
            background-color: #138496;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .info-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .info-box p {
            margin: 0;
            color: #333;
        }
        
        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="editor-header">
            <h1>Editor with Unsaved Edit Tracking</h1>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Ready</span>
            </div>
        </div>
        
        <div class="editor-content">
            <div class="info-box">
                <h4>How it works:</h4>
                <p>
                    This editor automatically tracks your unsaved changes and combines them with agent edits.
                    When you type, changes are recorded as "unsaved edits". When the agent makes changes,
                    your unsaved edits are preserved and combined intelligently.
                </p>
            </div>
            
            <div class="file-info">
                <strong>File:</strong> <span id="currentFilePath">files/example.py</span>
            </div>
            
            <textarea 
                id="editor" 
                class="editor-textarea" 
                placeholder="Start typing to see unsaved edit tracking in action..."
            >print("Hello, World!")
print("Still Here")
print("Still Here")
print("The End")
print("Goodbye Universe")</textarea>
            
            <div class="editor-actions">
                <button class="btn btn-primary" onclick="loadFile()">Load File</button>
                <button class="btn btn-success" onclick="saveFile()">Save File</button>
                <button class="btn btn-info" onclick="autoSaveFile()">Test Auto-Save</button>
                <button class="btn btn-warning" onclick="simulateAgentEdit()">Simulate Agent Edit</button>
                <button class="btn btn-secondary" onclick="clearUnsavedEdits()">Clear Unsaved Edits</button>
                <button class="btn btn-secondary" onclick="getUnsavedEdits()">Check Unsaved Edits</button>
            </div>
            
            <div class="log-container" id="logContainer">Editor ready. Start typing to see automatic file saving and unsaved edit tracking...</div>
        </div>
    </div>

    <!-- Include the version management scripts -->
    <script src="src/versionManager.js"></script>
    
    <script>
        // Initialize version manager
        const versionManager = new VersionManager();
        
        // Editor state
        let currentFilePath = 'files/example.py';
        let hasUnsavedChanges = false;
        let lastSavedContent = '';
        let autoSaveTimer = null;
        
        // Initialize editor
        const editor = document.getElementById('editor');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const logContainer = document.getElementById('logContainer');
        
        // Track changes
        editor.addEventListener('input', function() {
            handleContentChange();
        });
        
        // Debounced auto-save of file and unsaved edits
        function handleContentChange() {
            hasUnsavedChanges = true;
            updateStatus('unsaved', 'Unsaved changes');
            
            // Clear existing timer
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }
            
            // Set new timer to automatically save file and record unsaved edit
            autoSaveTimer = setTimeout(() => {
                autoSaveFile();
                recordUnsavedEdit();
            }, 1000); // Auto-save file and record unsaved edit after 1 second of no typing
            
            log(`Content changed, auto-saving file and recording unsaved edit in 1 second...`);
        }
        
        // Auto-save file whenever user makes changes
        async function autoSaveFile() {
            try {
                const content = editor.value;
                log(`Auto-saving file ${currentFilePath}...`);
                
                // Save the file to the file system
                const response = await fetch(`http://localhost:8000/files/write`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        path: currentFilePath,
                        content: content
                    })
                });
                
                if (response.ok) {
                    hasUnsavedChanges = false;
                    lastSavedContent = content;
                    updateStatus('saved', 'Saved');
                    log(`‚úÖ File automatically saved: ${currentFilePath}`);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Failed to auto-save file: ${error.message}`);
                // Don't update status on failure - keep showing unsaved changes
            }
        }

        // Record unsaved edit
        async function recordUnsavedEdit() {
            try {
                const content = editor.value;
                await versionManager.recordUnsavedUserEdit(
                    currentFilePath, 
                    content, 
                    'user', 
                    'Unsaved user edit'
                );
                log(`‚úÖ Recorded unsaved edit`);
            } catch (error) {
                log(`‚ùå Failed to record unsaved edit: ${error.message}`);
            }
        }
        
        // Load file
        async function loadFile() {
            try {
                log('Loading file...');
                const content = await fetch(`http://localhost:8000/files/read`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: currentFilePath })
                });
                
                if (!content.ok) {
                    throw new Error(`HTTP ${content.status}: ${content.statusText}`);
                }
                
                const data = await content.json();
                editor.value = data.content;
                lastSavedContent = data.content;
                hasUnsavedChanges = false;
                updateStatus('saved', 'File loaded');
                log(`‚úÖ File loaded: ${data.path}`);
            } catch (error) {
                log(`‚ùå Failed to load file: ${error.message}`);
            }
        }
        
        // Save file
        async function saveFile() {
            try {
                log('Saving file...');
                const content = editor.value;
                
                // Save to file store
                const response = await fetch(`http://localhost:8000/files/write`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        path: currentFilePath, 
                        content: content 
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Record as saved user edit
                await versionManager.recordUserEdit(
                    currentFilePath, 
                    content, 
                    'user', 
                    'User saved file'
                );
                
                // Clear unsaved edits
                await versionManager.clearUnsavedEdits(currentFilePath);
                
                lastSavedContent = content;
                hasUnsavedChanges = false;
                updateStatus('saved', 'File saved');
                log(`‚úÖ File saved successfully`);
            } catch (error) {
                log(`‚ùå Failed to save file: ${error.message}`);
            }
        }
        
        // Simulate agent edit
        async function simulateAgentEdit() {
            try {
                log('Simulating agent edit...');
                
                // CRITICAL: Save current file state before agent operations
                log('Saving current file state before agent operations...');
                const currentContent = editor.value;
                
                // Automatically save the file before agent operations
                log('Automatically saving file before agent operations...');
                await saveFile(); // This will save the current editor content to the file
                log('‚úÖ File automatically saved before agent operations');
                
                const backupResult = await versionManager.saveBeforeAgentOperation(
                    currentFilePath, 
                    currentContent, 
                    'user', 
                    'Save before agent edit simulation'
                );
                
                log(`‚úÖ File state backed up before agent operation: ${backupResult.backup_version_id}`);
                
                // Now simulate agent making a change
                const response = await fetch(`http://localhost:8000/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: `Make "Agent Modified This Line" be printed instead of "Goodbye Universe"`,
                        conversation_id: 'demo-conversation',
                        current_file: currentFilePath
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Reload the file to see the combined result
                setTimeout(() => {
                    loadFile();
                }, 2000);
                
                log(`‚úÖ Agent edit simulated, reloading file in 2 seconds...`);
                log(`üíæ Backup available at version: ${backupResult.backup_version_id}`);
                
            } catch (error) {
                log(`‚ùå Failed to simulate agent edit: ${error.message}`);
                
                // If agent edit failed, offer to restore from backup
                if (window.confirm('Agent edit failed. Would you like to restore from the backup?')) {
                    try {
                        // This would need the backup version ID from the previous operation
                        log('Restore functionality would be available here...');
                    } catch (restoreError) {
                        log(`‚ùå Failed to restore from backup: ${restoreError.message}`);
                    }
                }
            }
        }
        
        // Clear unsaved edits
        async function clearUnsavedEdits() {
            try {
                await versionManager.clearUnsavedEdits(currentFilePath);
                log(`‚úÖ Cleared unsaved edits`);
            } catch (error) {
                log(`‚ùå Failed to clear unsaved edits: ${error.message}`);
            }
        }
        
        // Get unsaved edits
        async function getUnsavedEdits() {
            try {
                const result = await versionManager.getUnsavedEdits(currentFilePath);
                log(`Unsaved edits: ${JSON.stringify(result, null, 2)}`);
            } catch (error) {
                log(`‚ùå Failed to get unsaved edits: ${error.message}`);
            }
        }
        
        // Update status indicator
        function updateStatus(status, text) {
            statusDot.className = `status-dot ${status}`;
            statusText.textContent = text;
        }
        
        // Log messages
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logContainer.textContent += `[${timestamp}] ${message}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('Editor initialized with unsaved edit tracking');
            updateStatus('ready', 'Ready');
        });
    </script>
</body>
</html>
